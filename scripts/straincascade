#!/bin/bash

# straincascade - Version 1.0.0
# Author: Sebastian Bruno Ulrich Jordi

# Main function script of StrainCascade pipeline

# Get the directory of this script (don't move the pipeline scripts from the original location)
script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Load utils from the script directory
utils_file="$script_dir/utils.sh"
if [ -f "$utils_file" ]; then
  source "$utils_file"
else
  echo "Error: utils.sh not found in $script_dir"
  exit 1
fi

# Default values
input=""
assembly_input=""
output_directory=$(get_absolute_path "$(pwd)")
sequencing_type="pacbio-hifi"
threads=32
locus_tag="automatic"
result_type="main"
force_overwrite="yes"
version="1.0.0"
databases_directory="$(dirname "$script_dir")/databases"
apptainer_images_dir="$(dirname "$script_dir")/apptainer_images"
execution_mode=""
bundle=""

# Valid sequencing types
valid_seq_types=("pacbio-raw" "pacbio-corr" "pacbio-hifi" "nano-raw" "nano-corr" "nano-hq")

# Valid result_type types
valid_result_types=("all" "main" "R")

# All available modules
all_modules=(
  "StrainCascade_Canu_correct_trim.sh"
  "StrainCascade_LJA_assembly.sh"
  "StrainCascade_SPAdes_assembly.sh"
  "StrainCascade_Canu_assembly.sh"
  "StrainCascade_Flye_assembly.sh"
  "StrainCascade_assembly_evaluation1.sh"
  "StrainCascade_MAC2_assembly_merging.sh"
  "StrainCascade_assembly_evaluation2.sh"
  "StrainCascade_Circlator_circularisation.sh"
  "StrainCascade_assembly_evaluation3.sh"
  "StrainCascade_arrow_medaka_polishing.sh"
  "StrainCascade_NGMLR_BBMap_coverage.sh"
  "StrainCascade_CheckM2_QC.sh"
  "StrainCascade_GTDB-Tk_taxonomy.sh"
  "StrainCascade_GTDB-Tk_de_novo_tree.sh"
  "StrainCascade_Bakta_annotation.sh"
  "StrainCascade_Prokka_annotation.sh"
  "StrainCascade_MicrobeAnnotator_annotation.sh"
  "StrainCascade_PlasmidFinder_identification.sh"
  "StrainCascade_RGI_antimicrobial_resistance_identification.sh"
  "StrainCascade_ResFinder_antimicrobial_resistance_identification.sh"
  "StrainCascade_dbCAN3_CAZymes_identification.sh"
  "StrainCascade_IslandPath_genomic_islands_identification.sh"
  "StrainCascade_VirSorter2_phage_identification.sh"
  "StrainCascade_DeepVirFinder_phage_identification.sh"
  "StrainCascade_run_summary"
  "StrainCascade_data_integration.sh"
)

# Function to print version
version() {
    echo "StrainCascade version $version"
    exit 0
}

# Function to check if a value is in an array
contains() {
    local value=$1
    shift
    for item; do
        [[ $item == "$value" ]] && return 0
    done
    return 1
}

# Function to check if a module is valid
is_valid_module() {
    local module=$1
    for valid_module in "${all_modules[@]}"; do
        if [[ $valid_module == "$module" ]]; then
            return 0
        fi
    done
    return 1
}

# Function to check if file is a FASTA or BAM file
is_fasta_or_bam_file() {
    local file=$1
    if [[ $file == *.fasta || $file == *.fa || $file == *.fastq || $file == *.fastq.gz || $file == *.fna || $file == *.bam ]]; then
        return 0
    else
        return 1
    fi
}

# Function to handle input
handle_input() {
    local input=$1
    local input_type=$2
    if [[ -f $input ]]; then
        echo $input
    elif [[ -d $input ]]; then
        local files=()
        for f in "$input"/*; do
            if [[ $input_type == "assembly" ]]; then
                if [[ $f == *.fasta || $f == *.fa || $f == *.fna ]]; then
                    files+=("$f")
                fi
            else
                if is_fasta_or_bam_file "$f"; then
                    files+=("$f")
                fi
            fi
        done
        if [[ ${#files[@]} -eq 0 ]]; then
            if [[ $input_type == "assembly" ]]; then
                echo "Warning: No assembly files found in the directory."
            else
                echo "Warning: No FASTA or BAM files found in the directory."
            fi
        fi
        echo "${files[@]}"
    else
        echo "Error: Invalid input directory or file." >&2
        exit 1
    fi
}

# Parse command line arguments
while getopts "i:a:o:s:t:e:b:r:f:d:l:hv" opt; do
    case "$opt" in
        i) input=$OPTARG ;;
        a) assembly_input=$OPTARG ;;
        o) output_directory=$OPTARG ;;
        s) sequencing_type=$OPTARG ;;
        t) threads=$OPTARG ;;
        e)
            if [[ $OPTARG == custom* ]]; then
                # Remove 'custom:' or 'custom' prefix and trim leading/trailing spaces
                normalized_arg=$(echo "$OPTARG" | sed -e 's/^custom:*\s*//;s/^\s*//;s/\s*$//')
                execution_mode="custom"
                custom_args=$normalized_arg
            else
                execution_mode=$OPTARG
            fi
            ;;
        b) bundle=$OPTARG ;;
        r) result_type=$OPTARG ;;
        f) force_overwrite=$OPTARG ;;
        d) databases_directory=$OPTARG ;;
        l) locus_tag=$OPTARG ;;
        h) help ;;
        v) version ;;
        *) usage ;;
    esac
done
shift $((OPTIND-1))

# Check for mutually exclusive -i and -a arguments
if [[ -n $input && -n $assembly_input ]]; then
    echo "Error: -i and -a are mutually exclusive. Please provide either input files (-i) or assembly files (-a), not both." >&2
    usage
fi

if [[ -z $input && -z $assembly_input ]]; then
    echo "Error: Either -i or -a must be provided." >&2
    usage
fi

# Determine input type
input_type="reads"
if [[ -n $assembly_input ]]; then
    input_type="assembly"
    input=$assembly_input
fi

# Check for mutually exclusive options
if [[ -n $bundle && -n $execution_mode ]]; then
    echo "Error: Bundle option (-b) cannot be used with execution mode (-e)" >&2
    exit 1
fi

# Set default execution mode if neither -e nor -b is specified
if [[ -z $bundle && -z $execution_mode ]]; then
    execution_mode="standard"
fi

# Validate execution_mode
valid_modes=("minimal" "efficient" "standard" "comprehensive" "custom")
if [[ -n $execution_mode && ! " ${valid_modes[*]} " =~ (^|[[:space:]])"$execution_mode"($|[[:space:]]) ]]; then
    echo "Error: Invalid execution mode. Valid options are: ${valid_modes[*]}" >&2
    exit 1
fi

# Handle custom execution mode
if [[ $execution_mode == "custom" ]]; then
    if [[ -z $custom_args ]]; then
        echo "Error: Custom execution mode requires arguments." >&2
        exit 1
    fi
fi
    
    # List all matching .sif files and store them in an array
    readarray -t matching_files < <(find "$apptainer_images_dir" -name 'python_3.12.4*.sif' -print)

    # Check the number of matching files
    if [ ${#matching_files[@]} -eq 0 ]; then
        echo "No matching .sif files found in $apptainer_images_dir." >&2
        exit 1
    elif [ ${#matching_files[@]} -gt 1 ]; then
        echo "Warning: Multiple matching .sif files found. Using the first match: ${matching_files[0]}"
    fi

# Proceed with the first match
straincascade_python=${matching_files[0]}

if ! outputs=$(apptainer exec --bind "$script_dir:/scripts" \
                              "$straincascade_python" \
                              /bin/bash -c "python /scripts/StrainCascade_run_configuration_handler.py '$execution_mode' '$bundle' '$custom_args'"); then
    echo "Error: Failed to process execution mode or bundle." >&2
    exit 1
fi

if [ -z "$outputs" ]; then
    echo "Error: No output received from Python script (StrainCascade_run_configuration_handler.py)." >&2
    exit 1
fi

# Separate the outputs by line breaks into an array
IFS=$'\n' read -rd '' -a outputs <<< "$outputs"

# Assign the outputs to separate variables
info_output="${outputs[0]}"
selected_modules="${outputs[1]}"
human_readable_output="${outputs[2]}"
    
# Validate the returned modules
for module in $selected_modules; do
    if ! is_valid_module "$module"; then
        echo "Error: Invalid module '$module' returned from custom execution mode." >&2
        exit 1
    fi
done


# Check if output directory exists and is writable
if [[ ! -d $output_directory ]]; then
    mkdir -p $output_directory
    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to create output directory." >&2
        exit 1
    fi
elif [[ ! -w $output_directory ]]; then
    echo "Error: Output directory is not writable." >&2
    exit 1
fi

# Check if sequencing type is valid
if ! contains "$sequencing_type" "${valid_seq_types[@]}"; then
    echo "Error: Invalid sequencing type. Valid options are: ${valid_seq_types[*]}" >&2
    exit 1
fi

# Check if number of threads is a positive integer
if ! [[ $threads =~ ^[1-9][0-9]*$ ]]; then
    echo "Error: Number of threads must be a positive integer." >&2
    exit 1
fi

# Check if result_type type is valid
if ! contains "$result_type" "${valid_result_types[@]}"; then
    echo "Error: Invalid result_type type. Valid options are: ${valid_result_types[*]}" >&2
    exit 1
fi

# Validate force_overwrite option
if ! [[ $force_overwrite == "yes" || $force_overwrite == "no" ]]; then
    echo "Error: Invalid option for force_overwrite. Valid options are: yes, no" >&2
    exit 1
fi

# Check if databases_directory directory exists
if [[ ! -d $databases_directory ]]; then
    echo "Error: Databases directory does not exist: $databases_directory" >&2
    exit 1
fi

# Validate locus tag if not "automatic"
if [[ $locus_tag != "automatic" ]]; then
    if [[ ! $locus_tag =~ ^[A-Z][A-Z0-9]{2,11}$ ]]; then
        echo "ERROR: INSDC-incompliant locus_tag parameter! INSDC locus tag prefixes must contain between 3 and 12 alphanumeric uppercase characters and start with a letter."
        exit 1
    fi
fi

# Handle input
input_files=$(handle_input "$input" "$input_type")
if [[ -z $input_files ]]; then
    echo "Error: No valid input files found." >&2
    exit 1
fi

echo "Initiating StrainCascade version ${version} execution with the following parameters:"
echo "Input type: $input_type"
echo "Input files: $input"
echo "Sequencing type: $sequencing_type"
echo "Threads: $threads"
echo "Run configuration:"
echo "$info_output" | tr ',' '\n'
echo "Selected modules:"
echo "$human_readable_output" | tr ',' '\n' | sed 's/^/- /'
echo "Result type: $result_type"
echo "Force overwrite: $force_overwrite"
echo "Output directory: $output_directory"
echo "Databases directory: $databases_directory"
echo "Locus tag: $locus_tag"

# Iterate over input files and run the pipeline
for input_file in $input_files; do
    bash StrainCascade_pipeline_wrapper.sh \
        "$(get_absolute_path "$script_dir")" \
        "$(get_absolute_path "$utils_file")" \
        "$(get_absolute_path "$input_file")" \
        "$(get_absolute_path "$output_directory")" \
        "$(get_absolute_path "$databases_directory")" \
        "$(get_absolute_path "$apptainer_images_dir")" \
        "$sequencing_type" \
        "$input_type" \
        "$threads" \
        "$selected_modules" \
        "$result_type" \
        "$force_overwrite" \
        "$locus_tag" \
        "$version"
done