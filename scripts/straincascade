#!/bin/bash

# Copyright (c) 2024-2025, University of Bern, Department for BioMedical Research, Sebastian Bruno Ulrich JORDI
# This source code is licensed under the MIT No Attribution License (MIT-0)
# found in the LICENSE file in the root directory of this source tree.

# Main function script of StrainCascade

# Get script directory in a portable way
if [ -n "${BASH_SOURCE[0]}" ]; then
    script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
elif [ -n "$0" ]; then
    script_dir="$( cd "$( dirname "$0" )" && pwd )"
else
    script_dir="$( cd "$(pwd)" && pwd )"
fi

# Load utils from the script directory
utils_file="$script_dir/utils.sh"
if [ -f "$utils_file" ]; then
  source "$utils_file"
else
  echo "Error: utils.sh not found in $script_dir"
  exit 1
fi

# Source installation utils for update functionality
installation_utils="$script_dir/StrainCascade_installation_utils.sh"
if [ -f "$installation_utils" ]; then
  source "$installation_utils"
else
  echo "Error: StrainCascade_installation_utils.sh not found in $script_dir"
  exit 1
fi

# Default values
input=""
assembly_input=""
output_directory=$(get_absolute_path "$(pwd)")
sequencing_type="pacbio-hifi"
threads=32
locus_tag="automatic"
result_type="main"
force_overwrite="yes"
selection_algorithm="contig"
version="1.0.0"
databases_directory="$(dirname "$script_dir")/databases"
apptainer_images_dir="$(dirname "$script_dir")/apptainer_images"
execution_mode=""
bundle=""
reproducibility_mode="heuristic"

# Valid sequencing types
valid_seq_types=("pacbio-raw" "pacbio-corr" "pacbio-hifi" "nano-raw" "nano-corr" "nano-hq")

# Valid result_type types
valid_result_types=("all" "main" "R")

# All available modules
all_modules=(
  "StrainCascade_Canu_correct_trim.sh"
  "StrainCascade_LJA_assembly.sh"
  "StrainCascade_SPAdes_assembly.sh"
  "StrainCascade_Canu_assembly.sh"
  "StrainCascade_Flye_assembly.sh"
  "StrainCascade_assembly_evaluation1.sh"
  "StrainCascade_MAC2_assembly_merging.sh"
  "StrainCascade_assembly_evaluation2.sh"
  "StrainCascade_Circlator_circularisation.sh"
  "StrainCascade_assembly_evaluation3.sh"
  "StrainCascade_arrow_medaka_polishing.sh"
  "StrainCascade_NGMLR_BBMap_coverage.sh"
  "StrainCascade_CheckM2_QC.sh"
  "StrainCascade_GTDB-Tk_taxonomy.sh"
  "StrainCascade_GTDB-Tk_de_novo_tree.sh"
  "StrainCascade_Bakta_annotation.sh"
  "StrainCascade_Prokka_annotation.sh"
  "StrainCascade_MicrobeAnnotator_annotation.sh"
  "StrainCascade_PlasmidFinder_identification.sh"
  "StrainCascade_AMRFinderPlus_antimicrobial_resistance_identification.sh"
  "StrainCascade_ResFinder_antimicrobial_resistance_identification.sh"
  "StrainCascade_dbCAN3_CAZymes_identification.sh"
  "StrainCascade_IslandPath_genomic_islands_identification.sh"
  "StrainCascade_VirSorter2_phage_identification.sh"
  "StrainCascade_DeepVirFinder_phage_identification.sh"
  "StrainCascade_CRISPRCasFinder_identification.sh"
  "StrainCascade_ISEScan_IS_elements_identification.sh"
  "StrainCascade_run_summary"
  "StrainCascade_data_integration.sh"
)

# Function to print version
version() {
    echo "StrainCascade version $version"
    exit 0
}

# Function to check if a value is in an array
contains() {
    local value=$1
    shift
    for item; do
        [[ $item == "$value" ]] && return 0
    done
    return 1
}

# Function to check if a module is valid
is_valid_module() {
    local module=$1
    for valid_module in "${all_modules[@]}"; do
        if [[ $valid_module == "$module" ]]; then
            return 0
        fi
    done
    return 1
}

# Function to check if file is a FASTA or BAM file
is_fasta_or_bam_file() {
    local file=$1
    if [[ $file == *.fasta || $file == *.fa || $file == *.fastq || $file == *.fastq.gz || $file == *.fna || $file == *.bam ]]; then
        return 0
    else
        return 1
    fi
}

# Function to handle input
handle_input() {
    local input=$1
    local input_type=$2
    if [[ -f $input ]]; then
        echo $input
    elif [[ -d $input ]]; then
        local files=()
        for f in "$input"/*; do
            if [[ $input_type == "assembly" ]]; then
                if [[ $f == *.fasta || $f == *.fa || $f == *.fna ]]; then
                    files+=("$f")
                fi
            else
                if is_fasta_or_bam_file "$f"; then
                    files+=("$f")
                fi
            fi
        done
        if [[ ${#files[@]} -eq 0 ]]; then
            if [[ $input_type == "assembly" ]]; then
                echo "Warning: No assembly files found in the directory."
            else
                echo "Warning: No FASTA or BAM files found in the directory."
            fi
        fi
        echo "${files[@]}"
    else
        echo "Error: Invalid input directory or file." >&2
        exit 1
    fi
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -i|--input) input="$2"; shift 2 ;;
        -a|--assembly_input) assembly_input="$2"; shift 2 ;;
        -ea|--external_assembly_dir)
            external_assembly_dir="$(get_absolute_path "$2")"
            if [[ ! -d "$external_assembly_dir" && -n "$external_assembly_dir" ]]; then
                echo "Warning: External assembly directory does not exist: $external_assembly_dir" >&2
            fi
            shift 2 ;;
        -o|--output_dir) output_directory="$2"; shift 2 ;;
        -s|--sequencing_type) sequencing_type="$2"; shift 2 ;;
        -t|--threads) threads="$2"; shift 2 ;;
        -e|--execution_mode) 
            if [[ $2 == custom* ]]; then
                normalized_arg=$(echo "$2" | sed -e 's/^custom:*\s*//;s/^\s*//;s/\s*$//')
                execution_mode="custom"
                custom_args=$normalized_arg
            else
                execution_mode="$2"
            fi
            shift 2
            ;;
        -b|--bundle) bundle="$2"; shift 2 ;;
        -r|--result_type) result_type="$2"; shift 2 ;;
        -sa|--selection_algorithm)
            if [[ "$2" == "contig" || "$2" == "continuity" ]]; then
                selection_algorithm="$2"
                shift 2
            else
                echo "Error: Invalid selection algorithm. Valid options are: contig, continuity" >&2
                exit 1
            fi
            ;;
        -f|--force) force_overwrite="$2"; shift 2 ;;
        -l|--locus-tag) locus_tag="$2"; shift 2 ;;
        --deterministic|--heuristic)
            if [[ "$1" == "--deterministic" ]]; then
                reproducibility_mode="deterministic"
            else
                reproducibility_mode="heuristic"
            fi
            shift 1
            ;;
        -us|--update-software)
            handle_software_update
            exit 0
            ;;
        -uai|--update-images)
            handle_images_update
            exit 0
            ;;
        -udb|--update-databases)
            handle_database_update
            exit 0
            ;;
        -h|--help)
            help
            ;;
        -v|--version)
            version
            ;;
        *)
            echo "Unknown option: $1" >&2
            usage
            ;;
    esac
done
shift $((OPTIND-1))

# Check for mutually exclusive -i and -a arguments
if [[ -n $input && -n $assembly_input ]]; then
    echo "Error: -i and -a are mutually exclusive. Please provide either input files (-i) or assembly files (-a), not both." >&2
    usage
fi

if [[ -z $input && -z $assembly_input ]]; then
    echo "Error: Either -i or -a must be provided." >&2
    usage
fi

# Determine input type
input_type="reads"
if [[ -n $assembly_input ]]; then
    input_type="assembly"
    input=$assembly_input
fi

# Check for mutually exclusive options
if [[ -n $bundle && -n $execution_mode ]]; then
    echo "Error: Bundle option (-b) cannot be used with execution mode (-e)" >&2
    exit 1
fi

# Set default execution mode if neither -e nor -b is specified
if [[ -z $bundle && -z $execution_mode ]]; then
    execution_mode="standard"
fi

# Validate execution_mode
valid_modes=("minimal" "efficient" "standard" "comprehensive" "custom")
if [[ -n $execution_mode && ! " ${valid_modes[*]} " =~ (^|[[:space:]])"$execution_mode"($|[[:space:]]) ]]; then
    echo "Error: Invalid execution mode. Valid options are: ${valid_modes[*]}" >&2
    exit 1
fi

# Handle custom execution mode
if [[ $execution_mode == "custom" ]]; then
    if [[ -z $custom_args ]]; then
        echo "Error: Custom execution mode requires arguments." >&2
        exit 1
    fi
fi

# Add this after the argument parsing loop
if [[ -n $reproducibility_mode && ! "$reproducibility_mode" =~ ^(deterministic|heuristic)$ ]]; then
    echo "Error: Invalid algorithm type. Must be either 'deterministic' or 'heuristic'" >&2
    exit 1
fi

# Find the necessary .sif file
straincascade_python=$(find_apptainer_sif_file "$apptainer_images_dir" 'python_3.12.4*.sif')


if ! outputs=$(apptainer exec --bind "$script_dir:/scripts" \
                              "$straincascade_python" \
                              /bin/bash -c "python /scripts/StrainCascade_run_configuration_handler.py '$execution_mode' '$bundle' '$custom_args'"); then
    echo "Error: Failed to process execution mode or bundle." >&2
    exit 1
fi

if [ -z "$outputs" ]; then
    echo "Error: No output received from Python script (StrainCascade_run_configuration_handler.py)." >&2
    exit 1
fi

# Separate the outputs by line breaks into an array
IFS=$'\n' read -rd '' -a outputs <<< "$outputs"

# Assign the outputs to separate variables
info_output="${outputs[0]}"
selected_modules="${outputs[1]}"
human_readable_output="${outputs[2]}"
    
# Validate the returned modules
for module in $selected_modules; do
    if ! is_valid_module "$module"; then
        echo "Error: Invalid module '$module' returned from custom execution mode." >&2
        exit 1
    fi
done


# Check if output directory exists and is writable
if [[ ! -d $output_directory ]]; then
    mkdir -p $output_directory
    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to create output directory." >&2
        exit 1
    fi
elif [[ ! -w $output_directory ]]; then
    echo "Error: Output directory is not writable." >&2
    exit 1
fi

# Check if sequencing type is valid
if ! contains "$sequencing_type" "${valid_seq_types[@]}"; then
    echo "Error: Invalid sequencing type. Valid options are: ${valid_seq_types[*]}" >&2
    exit 1
fi

# Check if number of threads is a positive integer
if ! [[ $threads =~ ^[1-9][0-9]*$ ]]; then
    echo "Error: Number of threads must be a positive integer." >&2
    exit 1
fi

# Check if result_type type is valid
if ! contains "$result_type" "${valid_result_types[@]}"; then
    echo "Error: Invalid result_type type. Valid options are: ${valid_result_types[*]}" >&2
    exit 1
fi

# Validate force_overwrite option
if ! [[ $force_overwrite == "yes" || $force_overwrite == "no" ]]; then
    echo "Error: Invalid option for force_overwrite. Valid options are: yes, no" >&2
    exit 1
fi

# Check if databases_directory directory exists
if [[ ! -d $databases_directory ]]; then
    echo "Error: Databases directory does not exist: $databases_directory" >&2
    exit 1
fi

# Validate locus tag if not "automatic"
if [[ $locus_tag != "automatic" ]]; then
    if [[ ! $locus_tag =~ ^[A-Z][A-Z0-9]{2,11}$ ]]; then
        echo "ERROR: INSDC-incompliant locus_tag parameter! INSDC locus tag prefixes must contain between 3 and 12 alphanumeric uppercase characters and start with a letter."
        exit 1
    fi
fi

# Handle input
input_files=$(handle_input "$input" "$input_type")
if [[ -z $input_files ]]; then
    echo "Error: No valid input files found." >&2
    exit 1
fi

echo "Initiating StrainCascade version ${version} execution with the following parameters:"
echo "Input type: $input_type"
echo "Input files: $input"
[[ -z "$external_assembly_dir" ]] && echo "External assembly directory for SC15: None provided" || echo "External assembly directory for SC15: $external_assembly_dir"
echo "Sequencing type: $sequencing_type"
echo "Threads: $threads"
echo "Run configuration:"
echo "$info_output" | tr ',' '\n'
echo "Selected modules:"
echo "$human_readable_output" | tr ',' '\n' | sed 's/^/- /'
echo "Result type: $result_type"
echo "Assembly selection algorithm: $selection_algorithm"
echo "Output directory: $output_directory"
echo "Databases directory: $databases_directory"
echo "Locus tag: $locus_tag"
echo "Reproducibility mode: $reproducibility_mode"

# Iterate over input files and run the pipeline
for input_file in $input_files; do
    bash StrainCascade_pipeline_wrapper.sh \
        "$(get_absolute_path "$script_dir")" \
        "$(get_absolute_path "$utils_file")" \
        "$(get_absolute_path "$input_file")" \
        "$(get_absolute_path "$external_assembly_dir")" \
        "$(get_absolute_path "$output_directory")" \
        "$(get_absolute_path "$databases_directory")" \
        "$(get_absolute_path "$apptainer_images_dir")" \
        "$sequencing_type" \
        "$input_type" \
        "$threads" \
        "$selected_modules" \
        "$result_type" \
        "$selection_algorithm" \
        "$force_overwrite" \
        "$locus_tag" \
        "$reproducibility_mode" \
        "$version"
done